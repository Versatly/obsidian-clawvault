/**
 * ClawVault Commands
 * Command palette registrations
 */

import { Notice, Platform, TFile, TFolder } from "obsidian";
import type ClawVaultPlugin from "./main";
import { generateCanvasTemplate } from "./canvas-templates";
import { openGeneratedCanvasPreview } from "./canvas-preview";
import { COMMAND_IDS, STATUS_VIEW_TYPE, TASK_BOARD_VIEW_TYPE } from "./constants";
import {
	BlockedModal,
	CaptureModal,
	OpenLoopsModal,
	TaskModal,
	TemplateModal,
} from "./modals";
import type { TemplateModalResult } from "./modals/template-modal";

/**
 * Register all ClawVault commands
 */
export function registerCommands(plugin: ClawVaultPlugin): void {
	// Generate Dashboard command
	plugin.addCommand({
		id: COMMAND_IDS.GENERATE_DASHBOARD,
		name: "ClawVault: Generate Dashboard",
		callback: () => {
			void generateDashboard(plugin);
		},
	});

	// Quick Capture command
	plugin.addCommand({
		id: COMMAND_IDS.QUICK_CAPTURE,
		name: "ClawVault: Quick Capture",
		hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "c" }],
		callback: () => {
			new CaptureModal(plugin.app).open();
		},
	});

	// Add Task command
	plugin.addCommand({
		id: COMMAND_IDS.ADD_TASK,
		name: "ClawVault: Add Task",
		hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "t" }],
		callback: () => {
			new TaskModal(plugin.app).open();
		},
	});

	// View Blocked command
	plugin.addCommand({
		id: COMMAND_IDS.VIEW_BLOCKED,
		name: "ClawVault: View Blocked Tasks",
		callback: () => {
			new BlockedModal(plugin.app, plugin.vaultReader).open();
		},
	});

	// Open Status Panel command
	plugin.addCommand({
		id: COMMAND_IDS.OPEN_STATUS_PANEL,
		name: "ClawVault: Open Status Panel",
		callback: () => {
			void activateStatusView(plugin);
		},
	});

	// Open Task Board command
	plugin.addCommand({
		id: COMMAND_IDS.OPEN_TASK_BOARD,
		name: "ClawVault: Open Task Board",
		callback: () => {
			void activateTaskBoardView(plugin);
		},
	});

	// Generate Canvas from Template command
	plugin.addCommand({
		id: COMMAND_IDS.GENERATE_CANVAS_FROM_TEMPLATE,
		name: "ClawVault: Generate Canvas from Template",
		callback: () => {
			new TemplateModal(plugin.app, async (result) => {
				await generateCanvasFromTemplate(plugin, result);
			}).open();
		},
	});

	// Force Refresh Stats command
	plugin.addCommand({
		id: COMMAND_IDS.REFRESH_STATS,
		name: "ClawVault: Refresh Stats",
		callback: () => {
			void plugin.refreshAll();
		},
	});

	// Show Open Loops command
	plugin.addCommand({
		id: COMMAND_IDS.SHOW_OPEN_LOOPS,
		name: "ClawVault: Show Open Loops",
		callback: () => {
			new OpenLoopsModal(plugin.app, plugin.vaultReader).open();
		},
	});

	// Setup Graph Colors command
	plugin.addCommand({
		id: "clawvault-setup-graph-colors",
		name: "ClawVault: Setup graph colors (neural style)",
		callback: () => {
			void setupGraphColors(plugin);
		},
	});
}

/**
 * Setup neural-style graph colors
 * Configures .obsidian/graph.json with colorGroups for each vault category
 */
async function setupGraphColors(plugin: ClawVaultPlugin): Promise<void> {
	try {
		const adapter = plugin.app.vault.adapter;

		// 1. Write the CSS snippet
		const snippetPath = ".obsidian/snippets/clawvault-graph.css";
		const snippetCSS = `/* ClawVault Graph Colors ‚Äî Neural Style */
/* Auto-generated by ClawVault plugin. Dark bg, colored nodes, green links. */

body.theme-dark .graph-view .graph-view-container { background-color: #0a0a0a; }

body.theme-dark .graph-view .node.tag-person circle { fill: #00b4d8 !important; }
body.theme-dark .graph-view .node.tag-project circle { fill: #2d6a4f !important; }
body.theme-dark .graph-view .node.tag-decision circle { fill: #e8590c !important; }
body.theme-dark .graph-view .node.tag-lesson circle { fill: #fcc419 !important; }
body.theme-dark .graph-view .node.tag-commitment circle { fill: #e03131 !important; }
body.theme-dark .graph-view .node.tag-task circle { fill: #22b8cf !important; }
body.theme-dark .graph-view .node.tag-observation circle { fill: #7950f2 !important; }
body.theme-dark .graph-view .node.tag-handoff circle { fill: #845ef7 !important; }
body.theme-dark .graph-view .node.tag-daily circle { fill: #495057 !important; }

body.theme-dark .graph-view .node.is-focused circle {
  fill: #e8a430 !important; stroke: #e8a430 !important;
  stroke-width: 3px; filter: drop-shadow(0 0 6px #e8a430);
}

body.theme-dark .graph-view .link { stroke: rgba(45, 200, 120, 0.15) !important; }
body.theme-dark .graph-view .link.is-focused { stroke: rgba(45, 200, 120, 0.6) !important; }
body.theme-dark .graph-view .node text { fill: #c1c2c5 !important; font-size: 0.8em; }
`;

		if (!await adapter.exists(".obsidian/snippets")) {
			await adapter.mkdir(".obsidian/snippets");
		}
		await adapter.write(snippetPath, snippetCSS);

		// 2. Enable the snippet
		const appearancePath = ".obsidian/appearance.json";
		let appearance: Record<string, unknown> = {};
		if (await adapter.exists(appearancePath)) {
			appearance = JSON.parse(await adapter.read(appearancePath));
		}
		const snippets = (appearance.enabledCssSnippets as string[]) || [];
		if (!snippets.includes("clawvault-graph")) {
			snippets.push("clawvault-graph");
			appearance.enabledCssSnippets = snippets;
			await adapter.write(appearancePath, JSON.stringify(appearance, null, 2));
		}

		// 3. Configure graph.json colorGroups
		const graphPath = ".obsidian/graph.json";
		let graphConfig: Record<string, unknown> = {};
		if (await adapter.exists(graphPath)) {
			graphConfig = JSON.parse(await adapter.read(graphPath));
		}
		graphConfig.colorGroups = [
			{ query: "path:people", color: { a: 1, rgb: 47316 } },
			{ query: "path:projects", color: { a: 1, rgb: 2976335 } },
			{ query: "path:decisions", color: { a: 1, rgb: 15227916 } },
			{ query: "path:lessons", color: { a: 1, rgb: 16565273 } },
			{ query: "path:tasks", color: { a: 1, rgb: 2275535 } },
			{ query: "path:commitments", color: { a: 1, rgb: 14680369 } },
			{ query: "path:backlog", color: { a: 1, rgb: 9806262 } },
			{ query: "path:inbox", color: { a: 1, rgb: 15964178 } },
			{ query: "path:handoffs", color: { a: 1, rgb: 8675063 } },
			{ query: "path:ledger", color: { a: 1, rgb: 7950066 } },
		];
		graphConfig.showTags = false;
		graphConfig.showAttachments = false;
		graphConfig.textFadeMultiplier = 0;
		graphConfig.nodeSizeMultiplier = 1.2;
		graphConfig.lineSizeMultiplier = 0.8;
		graphConfig.repelStrength = 10;
		graphConfig.linkDistance = 250;
		graphConfig.centerStrength = 0.5;
		await adapter.write(graphPath, JSON.stringify(graphConfig, null, 2));

		// 4. Generate Bases files for task management
		const basesFiles: Record<string, string> = {
			'all-tasks.base': `filters:\n  and:\n    - file.inFolder("tasks")\n    - status != "done"\nformulas:\n  age: (now() - file.ctime).days\n  status_icon: if(status == "blocked", "üî¥", if(status == "in-progress", "üî®", if(status == "open", "‚ö™", "‚úÖ")))\nviews:\n  - type: table\n    name: All Active Tasks\n    groupBy:\n      property: status\n      direction: ASC\n    order:\n      - formula.status_icon\n      - file.name\n      - status\n      - owner\n      - project\n      - priority\n      - blocked_by\n      - formula.age\n  - type: cards\n    name: Task Board\n    groupBy:\n      property: status\n      direction: ASC\n    order:\n      - file.name\n      - owner\n      - project\n      - priority`,
			'blocked.base': `filters:\n  and:\n    - file.inFolder("tasks")\n    - status == "blocked"\nformulas:\n  days_blocked: (now() - file.ctime).days\nviews:\n  - type: table\n    name: Blocked Tasks\n    order:\n      - file.name\n      - owner\n      - project\n      - blocked_by\n      - formula.days_blocked\n      - priority`,
			'by-project.base': `filters:\n  and:\n    - file.inFolder("tasks")\n    - status != "done"\nformulas:\n  status_icon: if(status == "blocked", "üî¥", if(status == "in-progress", "üî®", "‚ö™"))\nviews:\n  - type: table\n    name: By Project\n    groupBy:\n      property: project\n      direction: ASC\n    order:\n      - formula.status_icon\n      - file.name\n      - status\n      - owner\n      - priority`,
			'backlog.base': `filters:\n  and:\n    - file.inFolder("backlog")\nviews:\n  - type: table\n    name: Backlog\n    order:\n      - file.name\n      - source\n      - project\n      - file.ctime`,
		};

		for (const [filename, content] of Object.entries(basesFiles)) {
			if (!await adapter.exists(filename)) {
				await adapter.write(filename, content);
			}
		}

		new Notice("üêò Graph colors + task views configured! Open Graph View or Bases to see it.");
	} catch (error) {
		console.error("ClawVault: Failed to setup graph colors:", error);
		new Notice(`Failed to setup graph colors: ${error instanceof Error ? error.message : String(error)}`);
	}
}

/**
 * Generate dashboard using ClawVault CLI
 */
async function generateDashboard(plugin: ClawVaultPlugin): Promise<void> {
	// Check if we're on mobile
	if (Platform.isMobile) {
		new Notice("Dashboard generation requires the ClawVault CLI (desktop only)");
		return;
	}

	new Notice("Generating dashboard...");

	try {
		// Dynamic import for Node.js modules (desktop only)
		const childProcess = await import("child_process");
		const util = await import("util");
		const execAsync = util.promisify(childProcess.exec);

		// Get vault path
		const vaultPath = plugin.settings.vaultPathOverride || 
			(plugin.app.vault.adapter as { basePath?: string }).basePath;

		if (!vaultPath) {
			new Notice("Could not determine vault path");
			return;
		}

		// Run clawvault canvas command
		const { stdout, stderr } = await execAsync("clawvault canvas", {
			cwd: vaultPath,
			timeout: 30000,
		});

		if (stderr && !stderr.includes("warning")) {
			console.warn("ClawVault CLI stderr:", stderr);
		}

		// Try to find and open the generated canvas file
		const canvasMatch = stdout.match(/Created:\s*(.+\.canvas)/i) ||
			stdout.match(/(.+\.canvas)/);
		
		if (canvasMatch?.[1]) {
			const canvasPath = canvasMatch[1].trim();
			const file = plugin.app.vault.getAbstractFileByPath(canvasPath);
			if (file instanceof TFile) {
				await plugin.app.workspace.openLinkText(file.path, "", true);
				new Notice("Dashboard generated successfully");
			} else {
				new Notice(`Dashboard generated: ${canvasPath}`);
			}
		} else {
			new Notice("Dashboard generated successfully");
		}
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		
		if (errorMessage.includes("ENOENT") || errorMessage.includes("not found")) {
			new Notice("ClawVault CLI not found. Install with: npm i -g clawvault");
		} else {
			console.error("ClawVault: Dashboard generation failed:", error);
			new Notice(`Dashboard generation failed: ${errorMessage}`);
		}
	}
}

async function generateCanvasFromTemplate(
	plugin: ClawVaultPlugin,
	result: TemplateModalResult
): Promise<void> {
	new Notice("Generating canvas...");

	try {
		const tasks = await plugin.vaultReader.getAllTasks();
		const graphIndex = await plugin.vaultReader.readGraphIndex();
		const stats = await plugin.vaultReader.getVaultStats();
		const openLoops = await plugin.vaultReader.getOpenLoops(7);
		const decisionFiles = plugin.vaultReader.getRecentDecisionFiles(result.dateRangeDays, 12);
		const allFiles = plugin.app.vault.getMarkdownFiles();
		const vaultPath =
			plugin.settings.vaultPathOverride ||
			(plugin.app.vault.adapter as { basePath?: string }).basePath ||
			plugin.app.vault.getName();

		const canvasData = generateCanvasTemplate(result.templateId, vaultPath, {
			project: result.projectFilter,
			dateRangeDays: result.dateRangeDays,
			tasks,
			graphIndex,
			vaultName: stats.vaultName,
			allFiles,
			decisionFiles,
			openLoops,
			stats,
		});

		const dashboardsFolder = "dashboards";
		await ensureFolderExists(plugin, dashboardsFolder);
		const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
		const filePath = `${dashboardsFolder}/${result.templateId}-${timestamp}.canvas`;
		await plugin.app.vault.create(filePath, JSON.stringify(canvasData, null, 2));

		await openGeneratedCanvasPreview(plugin.app, filePath);
	} catch (error) {
		console.error("ClawVault: Canvas generation failed", error);
		new Notice(
			error instanceof Error
				? `Canvas generation failed: ${error.message}`
				: "Canvas generation failed."
		);
	}
}

async function ensureFolderExists(plugin: ClawVaultPlugin, folderPath: string): Promise<void> {
	const existing = plugin.app.vault.getAbstractFileByPath(folderPath);
	if (existing instanceof TFolder) {
		return;
	}
	if (existing instanceof TFile) {
		throw new Error(`Cannot create folder "${folderPath}" because a file already exists.`);
	}
	await plugin.app.vault.createFolder(folderPath);
}

/**
 * Activate the status view in the right sidebar
 */
async function activateStatusView(plugin: ClawVaultPlugin): Promise<void> {
	const { workspace } = plugin.app;

	// Check if view is already open
	let leaf = workspace.getLeavesOfType(STATUS_VIEW_TYPE)[0];

	if (!leaf) {
		// Create new leaf in right sidebar
		const rightLeaf = workspace.getRightLeaf(false);
		if (rightLeaf) {
			await rightLeaf.setViewState({
				type: STATUS_VIEW_TYPE,
				active: true,
			});
			leaf = rightLeaf;
		}
	}

	// Reveal the leaf
	if (leaf) {
		await workspace.revealLeaf(leaf);
	}
}

async function activateTaskBoardView(plugin: ClawVaultPlugin): Promise<void> {
	const { workspace } = plugin.app;
	let leaf = workspace.getLeavesOfType(TASK_BOARD_VIEW_TYPE)[0];

	if (!leaf) {
		const rightLeaf = workspace.getRightLeaf(false);
		if (rightLeaf) {
			await rightLeaf.setViewState({
				type: TASK_BOARD_VIEW_TYPE,
				active: true,
			});
			leaf = rightLeaf;
		}
	}

	if (leaf) {
		await workspace.revealLeaf(leaf);
	}
}
