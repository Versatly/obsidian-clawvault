/**
 * ClawVault Commands
 * Command palette registrations
 */

import { Notice, Platform, TFile } from "obsidian";
import type ClawVaultPlugin from "./main";
import { COMMAND_IDS, STATUS_VIEW_TYPE } from "./constants";
import { CaptureModal, TaskModal, BlockedModal } from "./modals";

/**
 * Register all ClawVault commands
 */
export function registerCommands(plugin: ClawVaultPlugin): void {
	// Generate Dashboard command
	plugin.addCommand({
		id: COMMAND_IDS.GENERATE_DASHBOARD,
		name: "Generate dashboard",
		callback: () => {
			void generateDashboard(plugin);
		},
	});

	// Quick Capture command
	plugin.addCommand({
		id: COMMAND_IDS.QUICK_CAPTURE,
		name: "Quick capture",
		callback: () => {
			new CaptureModal(plugin.app).open();
		},
	});

	// Add Task command
	plugin.addCommand({
		id: COMMAND_IDS.ADD_TASK,
		name: "Add task",
		callback: () => {
			new TaskModal(plugin.app).open();
		},
	});

	// View Blocked command
	plugin.addCommand({
		id: COMMAND_IDS.VIEW_BLOCKED,
		name: "View blocked tasks",
		callback: () => {
			new BlockedModal(plugin.app, plugin.vaultReader).open();
		},
	});

	// Open Status Panel command
	plugin.addCommand({
		id: COMMAND_IDS.OPEN_STATUS_PANEL,
		name: "Open status panel",
		callback: () => {
			void activateStatusView(plugin);
		},
	});

	// Setup Graph Colors command
	plugin.addCommand({
		id: "clawvault-setup-graph-colors",
		name: "Setup graph colors (neural style)",
		callback: () => {
			void setupGraphColors(plugin);
		},
	});
}

/**
 * Generate dashboard using ClawVault CLI
 */
async function generateDashboard(plugin: ClawVaultPlugin): Promise<void> {
	// Check if we're on mobile
	if (Platform.isMobile) {
		new Notice("Dashboard generation requires the ClawVault CLI (desktop only)");
		return;
	}

	new Notice("Generating dashboard...");

	try {
		// Dynamic import for Node.js modules (desktop only)
		const childProcess = await import("child_process");
		const util = await import("util");
		const execAsync = util.promisify(childProcess.exec);

		// Get vault path
		const vaultPath = plugin.settings.vaultPathOverride || 
			(plugin.app.vault.adapter as { basePath?: string }).basePath;

		if (!vaultPath) {
			new Notice("Could not determine vault path");
			return;
		}

		// Run clawvault canvas command
		const { stdout, stderr } = await execAsync("clawvault canvas", {
			cwd: vaultPath,
			timeout: 30000,
		});

		if (stderr && !stderr.includes("warning")) {
			console.warn("ClawVault CLI stderr:", stderr);
		}

		// Try to find and open the generated canvas file
		const canvasMatch = stdout.match(/Created:\s*(.+\.canvas)/i) ||
			stdout.match(/(.+\.canvas)/);
		
		if (canvasMatch?.[1]) {
			const canvasPath = canvasMatch[1].trim();
			const file = plugin.app.vault.getAbstractFileByPath(canvasPath);
			if (file instanceof TFile) {
				await plugin.app.workspace.openLinkText(file.path, "", true);
				new Notice("Dashboard generated successfully");
			} else {
				new Notice(`Dashboard generated: ${canvasPath}`);
			}
		} else {
			new Notice("Dashboard generated successfully");
		}
	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : String(error);
		
		if (errorMessage.includes("ENOENT") || errorMessage.includes("not found")) {
			new Notice("ClawVault CLI not found. Install with: npm i -g clawvault");
		} else {
			console.error("ClawVault: Dashboard generation failed:", error);
			new Notice(`Dashboard generation failed: ${errorMessage}`);
		}
	}
}

/**
 * Setup neural-style graph colors
 * Configures .obsidian/graph.json with colorGroups for each vault category
 */
async function setupGraphColors(plugin: ClawVaultPlugin): Promise<void> {
	try {
		const adapter = plugin.app.vault.adapter;

		// 1. Write the CSS snippet
		const snippetPath = ".obsidian/snippets/clawvault-graph.css";
		const snippetCSS = `/* ClawVault Graph Colors ‚Äî Neural Style */
/* Auto-generated by ClawVault plugin. Dark bg, colored nodes, green links. */

body.theme-dark .graph-view .graph-view-container {
  background-color: #0a0a0a;
}

body.theme-dark .graph-view .node.tag-person circle { fill: #00b4d8 !important; }
body.theme-dark .graph-view .node.tag-project circle { fill: #2d6a4f !important; }
body.theme-dark .graph-view .node.tag-decision circle { fill: #e8590c !important; }
body.theme-dark .graph-view .node.tag-lesson circle { fill: #fcc419 !important; }
body.theme-dark .graph-view .node.tag-commitment circle { fill: #e03131 !important; }
body.theme-dark .graph-view .node.tag-task circle { fill: #22b8cf !important; }
body.theme-dark .graph-view .node.tag-observation circle { fill: #7950f2 !important; }
body.theme-dark .graph-view .node.tag-handoff circle { fill: #845ef7 !important; }
body.theme-dark .graph-view .node.tag-daily circle { fill: #495057 !important; }

body.theme-dark .graph-view .node.is-focused circle {
  fill: #e8a430 !important;
  stroke: #e8a430 !important;
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px #e8a430);
}

body.theme-dark .graph-view .link { stroke: rgba(45, 200, 120, 0.15) !important; }
body.theme-dark .graph-view .link.is-focused { stroke: rgba(45, 200, 120, 0.6) !important; }
body.theme-dark .graph-view .node text { fill: #c1c2c5 !important; font-size: 0.8em; }
`;

		// Ensure snippets dir exists
		if (!await adapter.exists(".obsidian/snippets")) {
			await adapter.mkdir(".obsidian/snippets");
		}
		await adapter.write(snippetPath, snippetCSS);

		// 2. Enable the snippet in appearance.json
		const appearancePath = ".obsidian/appearance.json";
		let appearance: Record<string, unknown> = {};
		if (await adapter.exists(appearancePath)) {
			const raw = await adapter.read(appearancePath);
			appearance = JSON.parse(raw);
		}
		const snippets = (appearance.enabledCssSnippets as string[]) || [];
		if (!snippets.includes("clawvault-graph")) {
			snippets.push("clawvault-graph");
			appearance.enabledCssSnippets = snippets;
			await adapter.write(appearancePath, JSON.stringify(appearance, null, 2));
		}

		// 3. Configure graph.json with colorGroups
		const graphPath = ".obsidian/graph.json";
		let graphConfig: Record<string, unknown> = {};
		if (await adapter.exists(graphPath)) {
			const raw = await adapter.read(graphPath);
			graphConfig = JSON.parse(raw);
		}

		graphConfig.colorGroups = [
			{ query: "path:people", color: { a: 1, rgb: 47316 } },       // #00b4d8
			{ query: "path:projects", color: { a: 1, rgb: 2976335 } },   // #2d6a4f
			{ query: "path:decisions", color: { a: 1, rgb: 15227916 } }, // #e8590c
			{ query: "path:lessons", color: { a: 1, rgb: 16565273 } },   // #fcc419
			{ query: "path:tasks", color: { a: 1, rgb: 2275535 } },      // #22b8cf
			{ query: "path:commitments", color: { a: 1, rgb: 14680369 } }, // #e03131
			{ query: "path:backlog", color: { a: 1, rgb: 9806262 } },    // #95a5a6
			{ query: "path:inbox", color: { a: 1, rgb: 15964178 } },     // #f39c12
			{ query: "path:handoffs", color: { a: 1, rgb: 8675063 } },   // #845ef7
			{ query: "path:ledger", color: { a: 1, rgb: 7950066 } },     // #7950f2
		];
		graphConfig.showTags = false;
		graphConfig.showAttachments = false;
		graphConfig.textFadeMultiplier = 0;
		graphConfig.nodeSizeMultiplier = 1.2;
		graphConfig.lineSizeMultiplier = 0.8;
		graphConfig.repelStrength = 10;
		graphConfig.linkDistance = 250;
		graphConfig.centerStrength = 0.5;

		await adapter.write(graphPath, JSON.stringify(graphConfig, null, 2));

		new Notice("üêò Graph colors configured! Open Graph View to see the neural graph style.");
	} catch (error) {
		console.error("ClawVault: Failed to setup graph colors:", error);
		new Notice(`Failed to setup graph colors: ${error instanceof Error ? error.message : String(error)}`);
	}
}

/**
 * Activate the status view in the right sidebar
 */
async function activateStatusView(plugin: ClawVaultPlugin): Promise<void> {
	const { workspace } = plugin.app;

	// Check if view is already open
	let leaf = workspace.getLeavesOfType(STATUS_VIEW_TYPE)[0];

	if (!leaf) {
		// Create new leaf in right sidebar
		const rightLeaf = workspace.getRightLeaf(false);
		if (rightLeaf) {
			await rightLeaf.setViewState({
				type: STATUS_VIEW_TYPE,
				active: true,
			});
			leaf = rightLeaf;
		}
	}

	// Reveal the leaf
	if (leaf) {
		await workspace.revealLeaf(leaf);
	}
}
